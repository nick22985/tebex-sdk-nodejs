/**
 * Tebex Checkout API
 * The Checkout APIs are designed to allow our creators to use the Tebex Checkout flow and payment acceptance capabilities without the need to set up a Tebex-powered webstore. Using these APIs allows you to create baskets with custom products (as opposed to pre-created products on our webstore platform), and send customers directly to the checkout flow to proceed with payment options.  You must receive prior authorisation before the Checkout API is enabled on your account. Please contact customer support or your account manager to discover if you qualify to use the Checkout API before beginning integration.
 *
 * The version of the OpenAPI document: 1.1.2
 * Contact: tebex-integrations@overwolf.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { localVarRequest } from "../../../tebex-request";
import http from 'http';

/* tslint:disable:no-unused-locals */
import { RecurringPayment } from '../model/recurringPayment';
import { UpdateRecurringPaymentRequest } from '../model/updateRecurringPaymentRequest';
import { UpdateSubscriptionRequest } from '../model/updateSubscriptionRequest';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://checkout.tebex.io/api';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum RecurringPaymentsApiApiKeys {
}

export class RecurringPaymentsApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'tebex_checkout_auth_basic': new HttpBasicAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: RecurringPaymentsApiApiKeys, value: string) {
        (this.authentications as any)[RecurringPaymentsApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications.tebex_checkout_auth_basic.username = username;
    }

    set password(password: string) {
        this.authentications.tebex_checkout_auth_basic.password = password;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * This cancels the recurring payment for the reference provided. Recurring payment references start with `tbx-r-`
     * @summary Cancel a recurring payment
     * @param reference The recurring payment reference to cancel.
     */
    public async cancelRecurringPayment (reference: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RecurringPayment;  }> {
        const localVarPath = this.basePath + '/recurring-payments/{reference}'
            .replace('{' + 'reference' + '}', encodeURIComponent(String(reference)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reference' is not null or undefined
        if (reference === null || reference === undefined) {
            throw new Error('Required parameter reference was null or undefined when calling cancelRecurringPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.tebex_checkout_auth_basic.username && this.authentications.tebex_checkout_auth_basic.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.tebex_checkout_auth_basic.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {

            return new Promise<{ response: http.IncomingMessage; body: RecurringPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RecurringPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Fetch a recurring payment (subscription) by its reference
     * @param reference The recurring payment reference to fetch.
     */
    public async getRecurringPayment (reference: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RecurringPayment;  }> {
        const localVarPath = this.basePath + '/recurring-payments/{reference}'
            .replace('{' + 'reference' + '}', encodeURIComponent(String(reference)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reference' is not null or undefined
        if (reference === null || reference === undefined) {
            throw new Error('Required parameter reference was null or undefined when calling getRecurringPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.tebex_checkout_auth_basic.username && this.authentications.tebex_checkout_auth_basic.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.tebex_checkout_auth_basic.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {

            return new Promise<{ response: http.IncomingMessage; body: RecurringPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RecurringPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Pause or reactivate a recurring payment
     * @param reference The recurring payment reference to update.
     * @param updateRecurringPaymentRequest 
     */
    public async updateRecurringPayment (reference: string, updateRecurringPaymentRequest?: UpdateRecurringPaymentRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RecurringPayment;  }> {
        const localVarPath = this.basePath + '/recurring-payments/{reference}/status'
            .replace('{' + 'reference' + '}', encodeURIComponent(String(reference)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reference' is not null or undefined
        if (reference === null || reference === undefined) {
            throw new Error('Required parameter reference was null or undefined when calling updateRecurringPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateRecurringPaymentRequest, "UpdateRecurringPaymentRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.tebex_checkout_auth_basic.username && this.authentications.tebex_checkout_auth_basic.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.tebex_checkout_auth_basic.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {

            return new Promise<{ response: http.IncomingMessage; body: RecurringPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RecurringPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * If the new subscription amount is higher than the existing amount, a pro-rata charge will be made to cover the cost of the new price up until the next billing date.   **This endpoint requires prior approval - please contact your account manager.**
     * @summary Update a subscription with a new product / amount to pay - replacing the existing product
     * @param reference The recurring payment reference to fetch.
     * @param updateSubscriptionRequest 
     */
    public async updateSubscription (reference: string, updateSubscriptionRequest?: UpdateSubscriptionRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RecurringPayment;  }> {
        const localVarPath = this.basePath + '/recurring-payments/{reference}'
            .replace('{' + 'reference' + '}', encodeURIComponent(String(reference)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reference' is not null or undefined
        if (reference === null || reference === undefined) {
            throw new Error('Required parameter reference was null or undefined when calling updateSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateSubscriptionRequest, "UpdateSubscriptionRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.tebex_checkout_auth_basic.username && this.authentications.tebex_checkout_auth_basic.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.tebex_checkout_auth_basic.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {

            return new Promise<{ response: http.IncomingMessage; body: RecurringPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RecurringPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
